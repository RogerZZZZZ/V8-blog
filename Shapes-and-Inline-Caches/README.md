> Article: JavaScript engine fundamentals: Shapes and Inline Caches

> Author: Mathias

> [Original Link](https://mathiasbynens.be/notes/shapes-ics)

这篇文章描述了一些对于所有Javascript引擎来说常见且非常重要的基础--而不是仅仅针对V8（作者[Benedikt Meurer](https://twitter.com/bmeurer)&[Mathias Bynens](https://twitter.com/mathias)开发的引擎），作为一个JS开发者，理解JS引擎如何工作的可以帮助你优化你的代码。

### Javascript的管道

全部都开始于你所写出的JS代码。JS引擎解析源代码，然后将它转化为抽象语法树（AST）。基于AST解释器开始生成字节码，非常好！到这个时候，引擎开始真正的运行JS代码。

![1]()

为了让它运行的更快，字节码将会与分析数据一同被输入到优化编译器中。优化编译器根据这些信息作出一定的假设，之后生成高度优化的机器码。

如果在某个时刻其中一个假设结果为不正确，那么优化编译器将会进行逆优化，然后回到解释器中。

### 解释器/编译器在JS引擎中的管道

现在，让我们开始看真正运行你JS代码的管道部分，即代码被解释和优化的地方，之后复习一下一些主要JS引擎的区别。

通常来说，有一个包含一个解释器和一个优化编译器的管道。解释器快速的生成没有被优化的字节码，优化编译器花稍微长一点的时间并最后生成高度优化的机器码。

![2]()

下面的管道几乎就是V8(Chrome和Node.js所使用的引擎)的工作原理：

![3]()

V8中的解释器被称为`点火器-Ignition`，它的职责是生成和运行字节码。在运行的同时收集分析数据，这些数据将会加速之后的运行过程。当一个函数变`hot`，比如说执行更加频繁，生成的字节码和分析数据将会被传到`TurboFan`中，我们的优化编译器，去根据收集来的分析数据来生成优化的机器码。

![4]()

`SpiderMonkey`，Mozilla用在FireFox和SpiderNode中的JS引擎。其工作原理有一点不同于V8，它有两个优化编译器。解释器优化后到`Baseline`编译器中生成稍微优化后的代码。`IonMonkey`编译器则在使用代码运行时收集的分析数据来生成深度优化的代码。如果推测优化失败了，`IonMonkey`会回到`Baseline`阶段。

![5]()

`Chakra`，微软的在`Edge & Node-ChakraCore`中使用的JS引擎，也有相似的两个优化编译器作为开始。解释器优化后进入`SimpleJIT` - `JIT`意思为`Just-In-Time compile(及时编译器)`，在这里生成轻度优化的代码。再运用上分析数据，`FullJIT`会生成深度优化代码。

![6]()

`JavaScriptCore`（简称JSC），苹果在Safari和React Native中使用的JS引擎，使用了三个不同的优化编译器。`LLInt`，低级的解释器，之后到达`Baseline`编译器，再之后进入`DFG`(数据流图`Data Flow Graph`)编译器，最后进入FTL(Faster Than Light)编译器。

为什么有一些引擎会比其他引擎有更多的优化编译器？这都是一些权衡和取舍。一个解释器可以快速的生成字节码，但是通常来说字节码不是那么地高效。在另一方面一个优化编译器花更长的时间来最终生成更加有效率的机器码。这就是快速得到可以运行的代码或者是牺牲一些时间来让代码运行有更好的性能间的抉择。一些引擎选择加入一些有不同时间/效率特性的优化编译器，允许对这些权衡进行更细粒度的控制，但是代价是额外的复杂性。另一个权衡是内存的使用，可以在[我们后续的文章](https://mathiasbynens.be/notes/prototypes#tradeoffs)中寻找更多的观点。

我们只是提到了每个JS引擎中解释器和优化编译器管道的主要区别。但是除了这些区别，在更高的层面，所有的JS引擎都是相同架构的：都有一个分析器和一些解释器/编译器管道。


### JavaScript的对象模型

让我们通过研究一些方面是如何实现的来看看还有什么是JS引擎都具有的。

比如，JS引擎是如何实现JS对象模型，它们又是用什么奇技淫巧来加速在JS对象上的属性访问？最终你会发现所有主要的引擎实现都十分的类似。

`ECMAScript规范`将所有的对象如字典一样的定义过，每一个属性都有一个key值与之匹配。

![7]()

除了`[[Value]]]`本身以外，规范还定义了这些属性：

- `[[Writable]]` 决定属性是否可以被重新赋值
- `[[Enumerable]]` 决定属性是否可以在`for-in`循环中被遍历
- `[[Configurable]]` 决定属性是否可以被删除

`[[双中括号]]`表示看起来很funky，但是它确实是规范中定义不被直接暴露在外的属性的方法。你可以通过API`Object.getOwnPropertyDescriptor`来获得这些属性的值：

![8]()

好了，这就是JS如何定义对象，那数组又怎么样呢？

你可以将数组看作是对象的一个特例。一个区别在于数组对于数组下标有特殊的处理。数组索引在`ECMAScript规范`中时特殊的一个条目。JS中数组不能超过2的32次方-1个。在这个限制中所有索引值都是合法的，即从0到2的32次方-2的整数。

另一个区别在于数组有神奇的`length`属性。

![9]()

在这个例子中，创建了一个长度为2的数组，当在下标为2的地方赋值一个新的元素时，`length`会自动的更新。

JS定义了数组与对象相似。比如，所有keys包括数组索引都可以被用字符串来表示。数组中的第一个元素被存在key为`'0'`的地方。

![10]()

`length`属性恰好是一个不可枚举以及不可删除的属性。

一旦一个元素被加入到数组中，JS将会自动更新length的`[[Value]]`。

![11]()

一般来说，数组的行为和对象十分相似。

### 优化属性访问

现在我们知道了对象在JS中是怎么定义的了，让我们深入讨论JS引擎是如何有效的处理对象的。

目前为止属性访问在JS程序中是最常见的操作，所以对JS引擎来说让属性访问操作加速十分的重要。

![12]()

### Shapes - 形状、结构

在JS程序中，多个对象拥有相同属性的key是很普遍的。这样的对象就有相同的`shape`。

![13]()

使用相同`shape`去访问对象上的相同属性也十分的普遍。

![14]()

考虑到这一点，JS引擎可以根据对象的`shape`来优化对象属性访问。下面就是它如何工作的。

让我们假设我们有一个对象有`x`和`y`两个属性，它使用我们之前讨论的字典数据类型：包含字符串类型的key，它们指向对应的属性值。

![15]()

当你访问一个属性，比如`Object.y`，JS引擎会在`JSObject`中寻找key `y`，之后加载对应的属性值，最后返回`[[Value]]`.

但是这些属性值存在内存的什么位置呢？我们需要把它们作为`JSObject`的一部分存储吗？如果假设我们之后会看到更多对象具有这个`shape`，存储所有包含`JSObject`属性名和属性值的‘字典’将会非常的浪费。因为属性名在所有相同`shape`的对象中都是重复的。这就造成了大量的重复和没必要的内存使用。作为优化，引擎分开存储对象的`Shape`.

![16]()

`Shape`包含了除了`[[Value]]`以外所有的属性名和属性值。转而存储`JSObject`中值得偏移量，因此JS引擎知道在哪找到值。每个有相同`shape`的`JSObject`都指向这个`shape`的实例。现在每个`JSObject`只需要存储对于每个对象不同的值就可以了。

![17]()

当我们有多个对象时，优点就十分的明显。不管有多少个对象，只要它们的`shape`相同，我们只需要存储一次`shape`和属性信息！

所有引擎都使用`shape`来作为优化的一种手段，但是并不是多有的引擎都这么称呼：

- 学术论文一般称为`Hidden Classes`
- V8称它为`Map`
- Chakra称它为`Types`
- JavaScriptCore称为`Structures`
- SpiderMonkey称为`Shape`

在接下来的文章中，我们将继续称它为`shapes`

### 转换链和树

当你有一个具有一定`shape`的对象被添加一个属性时会发生什么？JS引擎是如何找到新的`shape`的？

![18]()

新的`shape`来源于一个在JS引擎中被称为转换链的东西，这里有一个例子：

![19]()

对象开始时没有任何的属性，所以指向一个空的`shape`。下一步就是添加了一个值为5的属性`x`到对象中，所以JS引擎将`shape`转换到包含属性`x`的形态，并且在`JSObject`偏移量为`0`的地方添加值`5`。在下一行中添加属性`y`，所以这时引擎转换到下一个包含`x & y`的`shape`，并且附加上值`6`到`JSObject`中(在偏移量为1的地方)。

> 注意: 属性添加的顺序印象`shape`，比如`{x: 4, y: 5}`生成出的shape与`{y: 5, x: 4}`不相同。

我们不需要存储每个`Shape`中所有的属性，而是，每个`Shape`只需要知道新引入的属性。比如：在这个例子中我们并没有必要再最后一个`shape`中存储`x`的信息，因为它可以在之前的结构中被找出。为了实现这个，每个`Shape`都有一个指向前一个`shape`的链接。

![20]()

如果你在JS代码中写`o.x`，JS引擎将会通过追溯转换链直到在一个`Shape`中招待属性`x`为止。

但是当没有办法创建转换链时会发生什么？比如，如果你有两个空对象，之后你在每个对象中加上不同的属性。

![21]()

在这种情况下，我们需要分支，而不是一个转换链，我们最后会得到一个转换树。

![22]()

这里我们创建了空对象`a`，在其中加入属性`x`。最后我们得到一个包含单个值得`JSObject`以及两个`shapes`：一个空`shape`以及一个带有属性`x`的`shape`。

第二个例子中同样开始于一个空对象`b`，但是之后我们附加上不同的属性`y`，最后我们得到两条`shape`链以及总共三个`shapes`.

但这就意味着我们总要由一个空`shape`开始吗？其实没有必要。引擎对已包含属性的对象做了一些优化。假设我们要么从空对象开始添加`x`，或是开始于一个包含`x`的对象。

![23]()

在第一个例子中，我们开始于一个空`shape`然后过渡到一个含有`x`的`shape`就像而我们之前看到的一样。

在`Object2`的例子中，直接生成从头开始已经有`x`的对象，而不是从空对象开始转换是有意义的。

![24]()

一个包含`x`的对象开始于一个包含`x`的`shape`，有效的跳过了空`shape`的阶段。这就是（至少）V8以及SpiderMonkey的做法。这样的优化缩短了转换链，也更加高效从字面量中构建对象。

Benedikt的博客[surprising polymorphism in React applications](https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc)讨论了这些微妙的操作是如何影响日常的性能的。

这里有一个例子，一个3D的点包含`x, y, z`三个属性。

![25]()



![26]()


![27]()


![28]()




##TO BE CONTINUED                                                                                                                          