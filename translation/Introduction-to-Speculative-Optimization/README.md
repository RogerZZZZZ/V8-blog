> Article: An Introduction to Speculative Optimization in V8
> Author: Benedikt Meurer
> Original Link: http://benediktmeurer.de/2017/12/13/an-introduction-to-speculative-optimization-in-v8/

# V8引擎中基于推测的优化介绍

可以在`JS Kongress`上关注我的一次演讲（[A Tale of TurboFan](https://www.youtube.com/watch?v=cvybnv79Sek)），我想要对关于TurboFan, V8 引擎的优化编译器如何工作以及V8是如何将你的JS代码便以为高性能的机器码进行一些补充讲解, 因为之前是演讲的缘故，我必须简短。所以在本文中将补充之前留下的坑，特别是在V8是如何收集和使用性能信息来完成基于推测的优化的。

### 总览

在深入研究TurboFan是如何工作之前，我简短地对V8如何工作进行在较高层面上进行解释。（picture taken from the “JavaScript Start-up Performance” blog post by my colleague Addy Osmani)

![Overview](https://github.com/RogerZZZZZ/V8-journeys/blob/master/translation/%08Introduction-to-Speculative-Optimization/1.png)

无论何时Chrome或者Node需要执行一些JS代码，都需要将源代码输入到V8。V8将代码输入到一个称为`Parser`的地方，`Parser` 创建了AST（抽象语法树），这个来源于我同事 [Marja Hölttä](https://twitter.com/marjakh)就这个话题如何在V8中工作有一个演讲[ “Parsing JavaScript — better lazy than eager?”](https://www.youtube.com/watch?v=Fg7niTmNNLg)。之后被输入到一个称为`Ignition Intepreter`转化为字节码流，之后再由`Ignition`执行。

在执行期间，`Ignition`收集关于输入的信息以及反馈给一些特定的操作。一些反馈信息就被`Ignition`自己使用来字节码的后续解释器。举例：对于像`o.x`这样的是属性访问，当o不变化时（即你一致都会传递`{x:v}` v为String给o），我们就会对如何拿到x的值进行缓存。再之后的字节码解析过程中我们将不会对`再o中需要属性x`的操作进行搜索。底层实现我们称之为内敛缓存(`inline cache`)。你可以在下面的blog中找到更多详情([“What’s up with monomorphism?”](https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html))。

更重要的是，基于你的工作量，由`Ignition`解释器收集来的反馈信息将被TurboFan进行处理来来生成初高性能的机器码，所用技术就是今天的主题推测优化。在这里，优化编译器将会查看所有类型的值，并推测我们将来需要相同的值，这将会让TurboFan减少很多不需要处理的工作，从而在最高性能情况下执行Javascript。

### 基本执行流

我们现在来看一个add函数是如何在V8中执行的
```javascript
function add(x, y) {
    return x + y
}

console.log(add(1, 2))
```

如果你在DevTools中执行,你会看到结果为3。

![Function add](https://github.com/RogerZZZZZ/V8-journeys/blob/master/translation/%08Introduction-to-Speculative-Optimization/2.png)

接下来我们看看V8是如何得到这个结果的。我们会一步一步的来看`function add`。在之前提到的，我们首先会将函数的原发解析为AST，这一步由`Parser`完成，你可以在`d8 shell`中通过命令`--print-ast` 来查看V8内部生成的AST。

```
$ out/Debug/d8 --print-ast add.js
…
--- AST ---
FUNC at 12
. KIND 0
. SUSPEND COUNT 0
. NAME "add"
. PARAMS
. . VAR (0x7fbd5e818210) (mode = VAR) "x"
. . VAR (0x7fbd5e818240) (mode = VAR) "y"
. RETURN at 23
. . ADD at 32
. . . VAR PROXY parameter[0] (0x7fbd5e818210) (mode = VAR) "x"
. . . VAR PROXY parameter[1] (0x7fbd5e818240) (mode = VAR) "y"
```

上述的代码不太好理解，我们将它以图片的形式展示：
![visulize function add](https://github.com/RogerZZZZZ/V8-journeys/blob/master/translation/%08Introduction-to-Speculative-Optimization/3.png)

开始，函数的字面量被解析为树的形态，一个子树为参数的声明，另一个子树是实际的函数体。在解析期间，是无法关联哪个名字对应哪个变量的。主要原因为JS中`变量提升`([funny var hoisting rules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting))以及`eval`，当然也还有其他的原因。在解析器开始时创建叫做`VAR PROXY`的节点，在随后的作用于分析阶段，会将`VAR PROXY`节点连接到`VAR`节点，或者标记他们为全局或者动态查找中的一种，这取决于解析器是否看到`eval`在周围的作用域中。

一旦完成我们就有了一个包含所有需要信息的AST去生成可执行的字节码。AST之后会被作为输入传到`BytecodeGenerator`, 这是`Ignition Interpreter`中的一部分用于生成以函数为单位的字节码。你可以通过`--print-bytecode`查看字节码的生成。
```
$ out/Debug/d8 --print-bytecode add.js
…
[generated bytecode for function: add]
Parameter count 3
Frame size 0
   12 E> 0x37738712a02a @    0 : 94                StackCheck
   23 S> 0x37738712a02b @    1 : 1d 02             Ldar a1
   32 E> 0x37738712a02d @    3 : 29 03 00          Add a0, [0]
   36 S> 0x37738712a030 @    6 : 98                Return
Constant pool (size = 0)
Handler Table (size = 16)
```

这告诉我们新的字节码对象被生成给了`function add`, 这个函数接受三个参数，隐式的接受`this`以及显式的接受`x 和 y`. 这个函数不需要局部变量（帧大小为0），并且包含以下四个字节码序列
```
StackCheck
Lder a1
Add a0, [0]
Return
```

为了解释这些，我们需要首先从较高层面来理解解释器是如何工作的，`Ignition`使用`register machine - 寄存器架构`(相对于之前在较早版本的V8中使用在FullCodegen compiler中的`stack machine`)。它保存了自己的局部状态，其中一些匹配到CPU的寄存器中，而另外的则匹配到实际机器的栈内存中的特定插槽(specific slots).

![how the interpreter works](https://github.com/RogerZZZZZ/V8-journeys/blob/master/translation/%08Introduction-to-Speculative-Optimization/4.png)

a0和a1两个特别的寄存器对应机器栈上函数的形参（在这个例子中我们有两个形参）。形参是在源代码中被声明的参数，与在函数运行时被传入的实际数值不同。每个字节码最后的计算值都会被保存在一个被称为累加器(accumulator)，当前的栈帧和激活记录被栈指针标识，而程序计数器(program counter)指向当前在字节码中执行的指令。接下来我们来看一个例子，关于每个独立字节码都做了什么：
- `栈检查(StackCheck)`比较stack point与一些上限的差别(实际上应该被称为下限，因为V8中栈的方向都是向下的)。如果栈高于某个阈值，我们就会停止函数的运行以及抛出`RangeError`以告知栈出现溢出。
- `Ldar a1`加载寄存器a1中的值到accumulator寄存器中。(Ldar 表示 Load Accumulator Register)
- `Add a0, [0]` 读取寄存器a0的值并累加到accumulator寄存器上，结果将会再次被放入accumulator寄存器中，`+`同样可以表示字符串的连接，`+`操作可以执行任意类型的操作数，`+`在JS中十分的复杂，有许多人在会谈中去阐明这种复杂性，比如 Emily Freeman 最近在 JS Kongress 中有一个题目为`”JavaScript’s “+” Operator and Decision Fatigue”`的主题演讲。`Add`操作符中的[0]指向一个`feedback vector slot`，即`Ignition`存储函数执行期间我们看到的值得分析信息。当我们之后讲解`TurboFan`如何优化函数的时候再回到这个话题。
- `Return` 结束当前函数的运行，以及将控制归还给调用者，返回值是accumulator寄存器中当前的值。

我的同事Franziska Hinkelmann 写了一篇文章[“Understanding V8’s Bytecode”](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)。这边文章将提供更多关于V8的字节码如何工作的细节。

### 推测优化

现在你对V8如何执行你的JS代码有了个大概的了解，现在是时候开始看`TurboFan`在图片中是干什么的了，以及你的JS代码如何变为高效的机器码。`+`操作符已经算是一个在JS中很复杂的操作了，在得出输入的相加结果之前需要进行大量的检查。

![Runtime Semantics](https://github.com/RogerZZZZZ/V8-journeys/blob/master/translation/%08Introduction-to-Speculative-Optimization/5.png)

要想将上述的几行机器指令以最高性能运行(可与Java 和 C++媲美)，关键字为推测优化，通过假设输入的可能性。举例：当我们知道x和y都为数字时，我们执行x+y,我们就不需要处理他们任意一个为string或是其他更糟糕的情况--在操作数可以任意JS对象类型之前，我们需要对其执行抽象方法`ToPrimitive`。

![ToPrimitive](https://github.com/RogerZZZZZ/V8-journeys/blob/master/translation/%08Introduction-to-Speculative-Optimization/6.png)

当我们知道x和y都是数字时，我们就可排除一些副作用---比如说它不会导致电脑关机，不会写入文件，或是跳转到另外一个页面。此外我们知道这个操作不会抛出异常。而这些都是优化的关键，因为一个优化编译器只有在确定该表达式执行不会抛异常或是导致一些副作用，表达式才可以进行优化。


## TO BE CONTINUED